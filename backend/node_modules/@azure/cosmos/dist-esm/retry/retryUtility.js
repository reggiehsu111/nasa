import * as tslib_1 from "tslib";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { Constants } from "../common/constants";
import { sleep } from "../common/helper";
import { StatusCodes, SubStatusCodes } from "../common/statusCodes";
import { LocationRouting } from "../request/LocationRouting";
import { DefaultRetryPolicy } from "./defaultRetryPolicy";
import { EndpointDiscoveryRetryPolicy } from "./endpointDiscoveryRetryPolicy";
import { ResourceThrottleRetryPolicy } from "./resourceThrottleRetryPolicy";
import { SessionRetryPolicy } from "./sessionRetryPolicy";
/**
 *
 * @param param0
 * @ignore
 */
export function execute({ retryContext = {}, retryPolicies, requestContext, executeRequest }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // TODO: any response
        if (!retryPolicies) {
            retryPolicies = {
                endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(requestContext.globalEndpointManager, requestContext.operationType),
                resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount, requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds, requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds),
                sessionReadRetryPolicy: new SessionRetryPolicy(requestContext.globalEndpointManager, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy),
                defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)
            };
        }
        if (!requestContext.locationRouting) {
            requestContext.locationRouting = new LocationRouting();
        }
        requestContext.locationRouting.clearRouteToLocation();
        if (retryContext) {
            requestContext.locationRouting.routeToLocation(retryContext.retryCount || 0, !retryContext.retryRequestOnPreferredLocations);
            if (retryContext.clearSessionTokenNotAvailable) {
                requestContext.client.clearSessionToken(requestContext.path);
            }
        }
        const locationEndpoint = yield requestContext.globalEndpointManager.resolveServiceEndpoint(requestContext);
        requestContext.endpoint = locationEndpoint;
        requestContext.locationRouting.routeToLocation(locationEndpoint);
        try {
            const response = yield executeRequest(requestContext);
            response.headers[Constants.ThrottleRetryCount] =
                retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
            response.headers[Constants.ThrottleRetryWaitTimeInMs] =
                retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
            return response;
        }
        catch (err) {
            // TODO: any error
            let retryPolicy = null;
            const headers = err.headers || {};
            if (err.code === StatusCodes.Forbidden && err.substatus === SubStatusCodes.WriteForbidden) {
                retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;
            }
            else if (err.code === StatusCodes.TooManyRequests) {
                retryPolicy = retryPolicies.resourceThrottleRetryPolicy;
            }
            else if (err.code === StatusCodes.NotFound &&
                err.substatus === SubStatusCodes.ReadSessionNotAvailable) {
                retryPolicy = retryPolicies.sessionReadRetryPolicy;
            }
            else {
                retryPolicy = retryPolicies.defaultRetryPolicy;
            }
            const results = yield retryPolicy.shouldRetry(err, retryContext, locationEndpoint);
            if (!results) {
                headers[Constants.ThrottleRetryCount] =
                    retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
                headers[Constants.ThrottleRetryWaitTimeInMs] =
                    retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMilliseconds;
                err.headers = Object.assign({}, err.headers, headers);
                throw err;
            }
            else {
                requestContext.retryCount++;
                const newUrl = results[1]; // TODO: any hack
                if (newUrl !== undefined) {
                    requestContext.endpoint = newUrl;
                }
                yield sleep(retryPolicy.retryAfterInMilliseconds);
                return execute({
                    executeRequest,
                    requestContext,
                    retryContext,
                    retryPolicies
                });
            }
        }
    });
}
//# sourceMappingURL=retryUtility.js.map