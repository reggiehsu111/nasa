import * as tslib_1 from "tslib";
import { AverageAggregator, CountAggregator, MaxAggregator, MinAggregator, SumAggregator } from "../Aggregators";
import { getInitialHeader, mergeHeaders } from "../headerUtils";
/** @hidden */
export class AggregateEndpointComponent {
    /**
     * Represents an endpoint in handling aggregate queries.
     * @constructor AggregateEndpointComponent
     * @param { object } executionContext - Underlying Execution Context
     * @ignore
     */
    constructor(executionContext, aggregateOperators) {
        this.executionContext = executionContext;
        // TODO: any
        this.executionContext = executionContext;
        this.localAggregators = [];
        this.respHeaders = getInitialHeader();
        aggregateOperators.forEach((aggregateOperator) => {
            switch (aggregateOperator) {
                case "Average":
                    this.localAggregators.push(new AverageAggregator());
                    break;
                case "Count":
                    this.localAggregators.push(new CountAggregator());
                    break;
                case "Max":
                    this.localAggregators.push(new MaxAggregator());
                    break;
                case "Min":
                    this.localAggregators.push(new MinAggregator());
                    break;
                case "Sum":
                    this.localAggregators.push(new SumAggregator());
                    break;
            }
        });
    }
    /**
     * Populate the aggregated values
     * @ignore
     */
    _getAggregateResult() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.toArrayTempResources = [];
            this.aggregateValues = [];
            this.aggregateValuesIndex = -1;
            const { result: resources, headers } = yield this._getQueryResults();
            resources.forEach((resource) => {
                // Newer API versions rewrite the query to return `item2`. It fixes some legacy issues with the original `item` result
                // Aggregatior code should use item2 when available
                const aggregateResult = resource.item2 ? resource.item2 : resource.item;
                this.localAggregators.forEach((aggregator) => {
                    aggregator.aggregate(aggregateResult);
                });
            });
            // Get the aggregated results
            this.localAggregators.forEach((aggregator) => {
                this.aggregateValues.push(aggregator.getResult());
            });
            return { result: this.aggregateValues, headers };
        });
    }
    /**
     * Get the results of queries from all partitions
     * @ignore
     */
    _getQueryResults() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.started = true;
            const { result: item, headers } = yield this.executionContext.nextItem();
            if (item === undefined) {
                // no more results
                return {
                    result: this.toArrayTempResources,
                    headers: this.getAndResetActiveResponseHeaders()
                };
            }
            this.toArrayTempResources = this.toArrayTempResources.concat(item);
            this.mergeWithActiveResponseHeaders(headers);
            return this._getQueryResults();
        });
    }
    mergeWithActiveResponseHeaders(headers) {
        mergeHeaders(this.respHeaders, headers);
    }
    getAndResetActiveResponseHeaders() {
        const ret = this.respHeaders;
        this.respHeaders = getInitialHeader();
        return ret;
    }
    /**
     * Execute a provided function on the next element in the AggregateEndpointComponent.
     * @memberof AggregateEndpointComponent
     * @instance
     * @param {callback} callback - Function to execute for each element. \
     * the function takes two parameters error, element.
     */
    nextItem() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let resHeaders;
            if (this.aggregateValues === undefined) {
                ({ headers: resHeaders } = yield this._getAggregateResult());
            }
            const resource = this.aggregateValuesIndex < this.aggregateValues.length
                ? this.aggregateValues[++this.aggregateValuesIndex]
                : undefined;
            return { result: resource, headers: resHeaders };
        });
    }
    /**
     * Retrieve the current element on the AggregateEndpointComponent.
     * @memberof AggregateEndpointComponent
     * @instance
     * @param {callback} callback - Function to execute for the current element. \
     * the function takes two parameters error, element.
     */
    current() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.aggregateValues === undefined) {
                const { headers } = yield this._getAggregateResult();
                return {
                    result: this.aggregateValues[this.aggregateValuesIndex],
                    headers
                };
            }
            else {
                return {
                    result: this.aggregateValues[this.aggregateValuesIndex],
                    headers: getInitialHeader()
                };
            }
        });
    }
    /**
     * Determine if there are still remaining resources to processs.
     * @memberof AggregateEndpointComponent
     * @instance
     * @returns {Boolean} true if there is other elements to process in the AggregateEndpointComponent.
     */
    hasMoreResults() {
        if (!this.started) {
            return true;
        }
        return (!this.started &&
            this.aggregateValues != null &&
            this.aggregateValuesIndex < this.aggregateValues.length - 1);
    }
}
//# sourceMappingURL=AggregateEndpointComponent.js.map